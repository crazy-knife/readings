
# 面向对象的思考过程
[TOC]
---
## 1.面向对象的概念简介
### 1.1 数据隐藏和封装
* 在面向对象的术语中，数据表现为属性，行为表现为方法。限制访问具体属性和（或）方法的行为叫做数据隐藏。
*  取值方法和赋值方法的理念就是数据隐藏。因为其他对象不应该直接操作另一个对象中的数据，而取值方法和赋值方法提供了对对象数据的访问控制。
    ```C#
    private string strName;
    public string Name
    {
        get {return this.strName;};
        set
        {
            if(value == null) return;
            this.strName = value;
        }
    }
    ```
* 使用对象的一个显著好处是对象无需暴露它的所有属性和行为。好的面向对象设计中，对象仅暴露必要的接口来和其他对象进行交互。
* 只有公共属性和方法被认为是接口。用户通过类接口与对象交互时，不应该看到该对象任何内部实现的部分。可以修改对象的内部实现，但不应该影响用户的代码。
### 1.2 继承
* 继承是面向对象程序设计实现==代码重用==的主要手段。继承允许一个类继承另一个类的属性和方法，通过抽象公共属性和行为来创建新类。
* 继承关系通常被称为==is-a==关系，当子类继承自父类时，任何父类能做的事情子类都可以做，即子类是父类的扩展。
### 1.3 多态
* 多态意味着相似的对象对相同的消息有着==不同的响应==。例如一个有很多形状的系统，圆形、正方形、星形的绘制方式不同。使用多态可以给这些形状发送相同的消息（例如Draw方法），每个形状可以响应自身的绘制。
### 1.4 组合
* 使用其他对象来构建或结合成新的对象，这种方式就是组合。组合关系可以称为==has-a==关系，比如计算机有(has-a)cpu、有(has-a)显卡、有(has-a)键盘。
---
## 2.以面向对象的方式进行思考
### 2.1 清楚接口和实现之间的区别
* 呈现给终端用户的服务暴露了接口。最佳实践中，只呈现给用户需要的接口，一个类的接口应该只包含需要用户知道的东西。当设计类时最重要的考虑就是==识别类的用户==。
* 实现细节对于用户是隐藏的，修改实现不需要改动用户代码。如果接口的设计是恰当的，那么即使调整了实现，用户调用代码也无需任何改变。接口包含了调用方法及返回值的语法。
### 2.2 使用抽象思维设计接口
* 面向对象编程的主要优势之一是可以==重用类==。可以重用的类比具体的类接口更加抽象，具体的接口可以是非常明确的，而抽象接口则更通用，高层次的抽象接口比高度具体的接口更有用。
### 2.3 尽可能提供最小化的用户接口
* 设计类时，通用规则是尽量不要让用户知道类内部的工作原理。
    - 只提供给用户绝对需要的东西。这意味着类的接口要尽可能少，应先从最小化的接口开始设计一个类。
    - 公共接口定义了用户可以访问什么。
    - 从用户角度定义类至关重要，而不是从信息系统的角度定义类。
    - 确保设计类时向真正的用户了解了需求和设计。
* 确定用户
    - 任何给构建对象==发送消息==的对象都可以认为是用户。
* 对象行为
    - 识别用户之后，必须确定对象行为。需要从每个用户的视角来开始识别每个对象的目的以及需要做的事情。
* 环境约束
* 识别公共接口
    - 收集用户信息、对象行为和环境信息后，需要为每个用户对象指定公共接口。
    - 得到最终的接口始终是一个迭代的过程，必须确定每个接口是否有利于对象的操作。
* 识别实现
    - 从技术角度来讲，任何==非公共接口==都可以视为实现。应该对用户完全隐藏实现细节。
---        
## 3.高级的面向对象概念
### 3.1 构造函数
* 当创建新对象时，首要事情之一就是调用构造函数。构造函数中的代码会把新创建的对象初始化到稳定、安全的状态，初始化属性时构造函数经常执行的功能。==如果类有属性，最好始终在构造函数中初始化这些属性==。
* 如果没有提供构造函数，系统会提供一个默认的构造函数。除了创建对象本身之外，默认构造函数的另一个行为是==调用父类的构造函数==。
* 设计类的一个最佳实践是==初始化所有属性==，构造函数用来确保应用程序处于稳定的状态。在设计时，优秀的实践应该是为所有属性识别一个稳定的状态，然后在构造函数中初始化这些属性为稳定的状态。
### 3.2 错误处理
* ==抛出异常==通常是处理错误的最佳方式。
### 3.3 作用域
* 一个类可以实例化出多个对象，每个对象有唯一的标识和状态。实例化的多个对象可以共享类中一些属性和方法，从而共享为这些属性和方法分配的内存。构造函数是一个被类所有实例共享的方法。
* 局部属性
    - 局部属性由特定的方法拥有。
* 对象属性
    - 可以在同一个对象中的多个方法中共享的属性。
* 类属性
    - 多个对象之间可以共享的属性，一个类中实例化的所有对象只会该属性分配一块单独的内存。在C#、Java、C++中，可以把类属性设置为==static==。
        ```C#
        public class Number
        {
            static int count;
        }
        ```
### 3.4 对象操作
* 深拷贝与浅拷贝
    - 所踪所有的引用，并对所有引用对象都创建拷贝，这种方式称为深拷贝。深拷贝会拥有很多层级，一个对象引用很多对象，而这些被引用的对象也可能引用其他对象。
    - 浅拷贝只会简单地拷贝引用，而不会深入层级。
    - 拷贝本身开销巨大。
---            
## 4.类的剖析
### 4.1 属性
* 属性代表了对象的状态，存储对象的相关信息。
* 尽可能==隐藏数据==是保持接口设计最小化的设计标准，属性应设置成私有，访问属性的唯一方式是使用类提供的方法接口。
### 4.2 构造函数
* 默认构造函数==不带任何参数==，如果提供了带参数的构造函数，系统就不会提供默认构造函数。
* 构造函数都定义为==public==，因为构造函数是类接口的成员。
### 4.3 访问器
* 对象之间的交互可以通过叫==访问器==的类型方法访问私有的属性，访问器又被称为取值方法(getter)和赋值方法(setter)。
    ```C#
    private string _Name;
    public string Name
    {
        get { return _Name; }
        set { _Name = value; }
    }
    ```  
* 如果属性是静态的(==static==)，并且类为该属性提供了一个赋值方法，其他对象调用该赋值方法只会修改同一个副本。因此，对该属性的修改会应用于所有对象。
### 4.4 公共接口方法
* 构造函数和访问器都被定义为公有的(==public==)，并且属于公共接口的一部分。
* 公共接口方法倾向于非常==抽象化==，而实现倾向于更==具体化==。
---                     
## 5.类设计指导
### 5.1 识别公共接口
* 最小化公共接口
    - 设计类时最重要的问题是保持公共接口最小化，提供最小化的公共接口可以保证类尽可能的简单。
* 隐藏实现
### 5.2 设计健壮的构造函数（以及析构函数）
* 构造函数应该把对象设置成安全的初始状态，包括属性初始化以及内存管理等问题。
* 在包含析构函数的语言中，析构函数包括了正确的清除功能。大多数情况下，清除功能就是释放对象在某些时间点被分配的系统内存，避免内存泄漏。
### 5.3 在类中设计错误处理
* 使用注释给类加上文档
    - 设计类时应该小心地记录过程，应保持文档和注释简单易懂。
* 构造可以合作的对象  
    - 设计类时，请确保知道其他对象如何与之交互。
### 5.4 设计类时请考虑重用
### 5.5 设计类时考虑扩展性
* 使用描述性的名称
    - ==保持命名具有描述性==是优秀的开发实践。类、属性和方法遵循命名约定很重要，确保这些约定是有意义的，每个相关的人都能理解背后的意图。
* 抽象不可移植的代码
    - 如果设计的系统必须使用不可移植的（原生的）代码，那么应该把这些代码抽象到类中。通过抽象，可以将这些不可移植的代码隔离到各自的类中，或至少隔离在方法中（一个可以被重载的方法）。
* 提供一种方式来复制和比较对象
    - 深拷贝、浅拷贝
* 保持尽可能小的作用域
    - 尽可能的局部化属性和行为，这样维护、测试和扩展类都变得更加容易。
* 类的职责与自身高度相关    
### 5.6 设计类时考虑可维护性 
* 设计有用且简明的类促进了高层次的可维护性。任何修改系统的行为应当只修改对象的具体实现，应当避免对公共接口的改变。  
* 促进可维护性的方式之一是==减少代码依赖==，保持类的耦合度越低越好。      
* 在开发过程中使用迭代，用小步增长的方式来编写代码，每步都进行构建和测试。
* 测试接口
    - 接口的最小实现通常称为桩（stub），使用桩可以在没有编写任何真实代码的情况下测试接口。
### 5.7 使用对象持久化
* 序列化以及反序列化
---            
## 6.使用对象进行设计
### 6.1 设计指导
* 创建优秀的设计最重要的因素是找到一个合适的设计方法并且坚持使用该方法。
* 提供正确的分析
    - 在设计和创造软件产品时会引入很多变量。用户必须和设计人员通过正确的分析确定工作陈述文档、项目需求。
    - 假设项目是可行的，分析阶段主要关注点是让每个人学习这些系统（包括旧系统及新系统原型）来确定系统需求。
* 编写工作陈述文档
    - 工作陈述（SOW）是描述系统的文档，它必须代表完整的系统，而且很清楚这个系统的外观和用法。
* 收集需求
    - 需求文档描述了用户期望的系统。需求文档不需要具备高度的技术细节，但需求必须是详尽的，能充分代表用户对最终产品所需的本质。
    - 软件开发过程中的所有未来文档都要基于需求。
* 开发用户接口的原型
    - 确保用户和开发人员理解系统的最好方式之一就是创建一个原型。
    - 创建原型无须实现业务逻辑，原型应该模拟用户接口。
* 识别类
    - 在需求文档后，就可以开始识别类了。
* 确定每个类的职责
* 确定类之间如何协作
* 创建类模型来描述系统
    - 当识别出所有的类，并且这些类的职责和协作都已经清晰，那么可以构造一个类模型来表示整个系统。
### 6.2 对象包装
* 对象包装的主要目的是为使用代码的程序员提供一致的接口。
* 包装结构化代码
    - 在结构化设计中，可以将代码包装到函数；在面向对象设计中，将代码包装到对象和方法中。
* 包装不可移植的代码
    - 对象包装的另一个用途是隐藏不可移植的（或原生的）代码。
* 包装已有类
---
## 7.继承和组合
### 7.1 重用对象
* 通过继承和组合来利用其它类就可以构建新的类（其最终变成对象）
* 继承代表了==is-a==关系
* 组合代表了==has-a==关系
### 7.2 继承
* 通用和特例
    - 继承是根据通用因素从通用到具体的过程，即在继承树中，越往下，事情变得越特殊，最通用的事情位于树的顶端。
* 设计决策
    - 理论上，找到越多的共同点越好，但是找出的点越多，系统会越复杂。
    - 决定在设计时引入更小的复杂度或者更多的功能是一项平衡艺术。我们的主要目标是创建一个系统，该系统保持一定的弹性，引入复杂度时不至于被自身压垮。
### 7.3 组合
* 一个对象包含其他对象就是组合
* 使用过多的组合也会导致更高的复杂度
### 7.4 封装是面向对象的本质
* 封装就是把类打包成公共接口和私有实现的过程，本质上，一个类应该隐藏其他类无需了解的任何事情。
* 继承减弱封装
    - 父类的修改会波及整个类的体系结构，潜在影响所有继承实现的子类。
    - 使用继承时严格考量==is-a==条件是非常重要的。如果子类真的是父类的特殊类型，对父类的修改会影响到子类，这是自然和期望的行为。
---
## 8.框架和重用：使用接口和抽象类进行设计
### 8.1 框架
* 框架可以实现标准化（插拔机制）和重用准则。
### 8.2 契约
* 契约定义为要求开发人员遵循API规格要求的一种机制，标准化编码的约定。在Java和.NET语言中，实现契约的两种方式是使用抽象类和接口。
* 抽象类
    - 抽象类包含一个或多个没有提供任何实现的方法，也可以提供实体方法。
    - 子类必须要实现抽象父类中声明的抽象方法，这些抽象方法就是契约。
* 接口
    - 接口完全不能提供任何实现，所以任何实现某个接口的类必须提供实现所有方法。
    - 当使用接口时，无须考虑正式的继承体系，如果设计上是合理的，理论上可以为任何类添加接口。而抽象类要求继承自该抽象类，并且延伸至其自身所有可能的父类。
* 继承是严格的==is-a==关系，但接口不是。
* 定义契约的简单规则就是通过抽象类或接口提供一个不包含实现的方法。
---
## 9.创建对象及面向对象设计
### 9.1 组合关系
* 使用组合的原因是通过组合可以降低构建系统的复杂度。
* 组合也保证了组件的可替换性。
* 使用组合是可以分别构建系统和子系统，而且这些系统是可以被独立测试和维护的。
### 9.2 分阶段构建
* 稳定的复杂系统通常具有一定的层级结构，每个系统由更简单的子系统构建而成，这些子系统又由更简单的子系统构建而成。
* 稳定的复杂系统是可分解的。
* 稳定的复杂系统往往由不同类型的子系统以不同的方式组合而成。
* 可工作的复杂系统往往是从可工作的简单系统演化而来。
### 9.3 组合类型
* 聚合是指复杂的对象由其他对象组成。而当一个对象需要其他对象的服务时则使用联合。
* 联合和聚合的微小区别在于部分如何构成整体。在聚合中，通常只看到整体；而在联合中，通常看到的是组成整体的部分。
### 9.4 避免依赖
* 使用组合时要求避免对象之间高度依赖。最佳实践是一个领域中的对象不应当和另一个领域中的对象混合，除非有非常特殊的情况。
