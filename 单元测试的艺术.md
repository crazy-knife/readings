
# 单元测试的艺术
[TOC]
---
## 1.单元测试基础
### 1.1 定义
+ 工作单元
    - 从调用系统的一个公共方法到产生一个测试可见的最终结果，其间这个系统发生的行为总称为一个工作单元。
    - 测试可见的最终结果可以是：
    1.被调用的公共方法返回一个值（一个返回值不为空的函数）。
    2.在方法调用的前后，系统的状态或行为有可见的变化，这种变化无需查询私有状态即可判断。
    3.调用了一个不受测试控制的第三方系统，这个系统不返回任何值，或者返回值都被忽略。
+ 单元测试
    - 一个单元测试是一段代码，这段代码调用一个工作单元，并检验改工作单元的一个具体的最终结果。
### 1.2 优秀单元测试的特征
+ 它应该是自动化的，可重复执行；
+ 它应该很容易实现；
+ 它应该第二天还有意义；
+ 任何人都能一键运行，优秀的单元测试可被任何人访问和运行；
+ 它应该运行速度很快；
+ 它的结果应该是稳定的；
+ 它应该能完全控制被测试的单元；
+ 它应该完全隔离的（独立于其他测试的运行）；
+ 如果它失败了，应该很容易发现什么是期待的结果，进而定位问题所在。
### 1.3 集成测试
+ 集成测试是对一个工作单元进行的测试，这个测试对被测试的工作单元没有完全的控制，并使用该单元的一个或多个真实依赖物，例如时间、网络、数据库、线程等。
### 1.4 什么是优秀的单元测试
+ 一个单元测试是一段自动化的代码，这段代码调用被测试的工作单元，之后对这个单元的单个最终结果的某些假设进行验证。
+ 单元测试几乎都是用自动化测试框架编写。
+ 单元测试容易编写，能快速运行。
+ 单元测试可靠、可读，并且可维护。只要产品代码不发生变化，单元测试的结果是稳定的。
### 1.5 测试驱动开发（TDD）
+ TDD的技术
    - 编写一个会失败的测试，以证明产品中代码或者功能的缺失。
    - 编写符合测试预期的产品代码，使测试通过。
    - 重构代码。
+ 成功进行TDD的三种核心技能
    - 仅仅做到先编写测试，并不能保证测试是可维护、可读以及可靠的。
    - 仅仅做到编写的测试可读、可维护，并不能保证获得先编写测试的各种好处。
    - 仅仅做到先编写测试，并且测试可读、可维护，并不能保证得到一个设计完善的系统。（设计能力才是使代码优美、可维护的关键）
---
## 2.单元测试框架
### 2.1 单元测试框架
+ 轻松编写结构化的测试
    - 可以继承的基础类或接口
    - 置于代码中，用来标记测试方法的属性
    - 提供特殊断言方法的断言类，用于验证代码
+ 执行一个或全部单元测试
    - 发现代码中的测试
    - 自动运行测试
    - 运行期间显示状态
    - 可以用命令行自动化
+ 查看测试运行结果
### 2.2 NUnit单元测试框架
+ 在代码中使用NUnit属性
    - 属性[TestFixture]标识一个包含自动化NUnit测试的类。
    - 属性[Test]标识一个需要调用的自动化测试的方法。
        ```C#
        [TestFixture]
        public class LogAnalyzerTests
        {
            [Test]
            public void IsVaildFileName_BadExtension_ReturnsFalse()
            {

            }
        }
        ```
+ 单元测试的三个行为
    - 准备(Arrange)对象，创建对象，进行必要的设置；
    - 操作(Act)对象；
    - 断言(Assert)某件事情是预期的。
        ```C#
        [Test]
        public void IsVaildFileName_BadExtension_ReturnsFalse()
        {
            LogAnalyzer analyzer = new LogAnalyzer();
            bool result = analyzer.IsValidLogFileName("filewithbadextension.foo");
            Assert.False(result);
        }
        ```
+ NUnit参数化测试
    - 把属性[Test]替换成属性[TestCase];
    - 把测试中用到的硬编码的值替换成测试方法的参数；
    - 把替换掉的值放在属性的括号中[TestCase(param1,param2,...)]；
        ```C#
        [TestCase("filewithgoodextension.SLF")]
        [TestCase("filewithgoodextension.slf")]
        public void IsVaildFileName_ValidExtension_ReturnsTrue(string file)
        {
            LogAnalyzer analyzer = new LogAnalyzer();
            bool result = analyzer.IsValidLogFileName(file);
            Assert.True(result);
        }
        ```
        ```C#
        [TestCase("filewithgoodextension.SLF"),true]
        [TestCase("filewithgoodextension.slf"),true]
        [TestCase("filewithgoodextension.foo"),false]
        public void IsVaildFileName_ValidExtension_ChecksThem(string file,bool expected)
        {
            Loganalyzer analyzer = new Loganalyzer();
            bool result = analyzer.IsValidLogFileName(file);
            Assert.AreEqual(expected,result);
        }
        ```
+ UNuit更多属性
    - [SetUp]属性：每次在运行测试类里的任何一个测试时都会先运行这个setup方法。
    - [TearDown]属性标识一个方法应该在测试类里的每个测试运行之后执行。
    - 可以把setup方法和teardown方法看成测试类中测试的构造函数和析构函数。
    - 随着代码的增加，setup方法后面的测试方法很快变得难以阅读，应该避免使用setup方法初始化被测试类的实例。可使用工厂方法代替。
        ```C#
        [TestFixture]
        public class LogAnalyzerTests
        {
            private LogAnalyzer m_analyzer = null;
            [SetUp]
            public void SetUp()
            {
                m_analyzer = new LogAnalyzer();
            }
            [Test]
            public void IsVaildFileName_ValidFileLowerCased_ReturnsTrue()
            {
                bool result = m_analyzer.IsValidLogFileName("whatever.slf");
                Asser.IsTrue(result,"filename should be valid!");
            }
            [TearDown]
            public void TearDown()
            {
                // 反模式，不是必须的，真实测试中请勿使用
                m_analyzer = null;
            }
        }
        ```
    - 检验预期的异常：保证当异常应该抛出时，被测试的方法能够抛出正确的异常。
        ```C#
        [Test]
        public void IsValidFileName_EmptyFileName_Throws()
        {
            // 使用工厂方法创建实例
            LogAnalyzer la = MarkAnalyzer();
            // 使用Assert.Catch<T>(delegate)调用被测试方法,Assert.Catch函数返回Lambda内抛出的异常实例
            var ex = Assert.Catch<Exception>(() => la.IsValidLogFileName(""));
            StringAssert.Contains("filename has to be provided",ex.Message);
        }
        ```
### 2.3 测试系统状态的改变
+ 基于状态的测试（状态验证）
    - 通过检查被测试系统及其协作方（依赖物）在被测试方法执行后行为的改变，判定被测试方法是否正确工作。
        ```C#
        // 通过调用IsValidLogFileName测试属性值
        public class LogAnalyzer
        {
            public bool WasLastFileNameVaild 
            {
                get;
                set;
            }
            public bool IsValidLogFileName(string fileName)
            {
                WasLastFileNameVaild = false;               // 改变系统状态
                if(string.IsNullOrEmpty(fileName))
                {
                    throw new ArgumentException("filename has to be provided");
                }
                if(!fileName.EndsWith(".SLF",StringComparison.CurrentCultureIgnoreCase))
                {
                    return false;
                }
                WasLastFileNameVaild = true;                // 改变系统状态
                return true;
            }
        }
        ```
        ```C#
        // 通过调用一个方法然后检查属性值测试一个类
        [TestCase("badfile.foo",false)]
        [TestCase("badfile.slf",true)]
        public void IsVaildFileName_WhenCalled_ChangesWasLastFileNameVaild(string file,bool expected)
        {
            LogAnalyzer la = MarkAnalyzer();
            la.IsValidLogFileName(file);
            // 对系统状态进行断言
            Assert.AreEqual(expected,la.WasLastFileNameVaild);
        }
        ```
---
## 3.使用存根破除依赖
### 3.1 存根 
+ 外部依赖项：一个外部依赖项是系统中的一个对象，被测试代码与这个对象发生交互，但你不能控制这个对象。（常见的外部依赖项包括文件系统、线程、内存等）
+ 存根：是对系统中存在的依赖项（或者协作者）的可控制的替代物。通过使用存根，在测试代码时无需直接处理依赖项。
### 3.2 如何使测试变得容易
+ 抑制测试：代码对一个外部资源有某种依赖，尽管代码本身的逻辑是完全正确的，但是这种依赖可能导致测试失败。
+ 破除依赖使测试变得容易
    - 找到被测试对象使用的外部接口或API。
    - 把这个接口的底层实现替换成你能控制的东西。
+ 代码层面破除依赖
    - 找到被测试的工作单元的开始部分使用的接口。
    - 如果这个接口与被测试工作单元直接相连（如读取文件系统、读取数据库等等），在代码中添加一个间接层，隐藏这个接口，就可以使代码能够测试。
    - 把这个交互接口的底层实现替换成可以控制的代码。
### 3.3 重构代码设计以提高可测试性
+ 重构：在不改变代码功能的前提下对代码的修改。
+ 接缝：代码中可以插入不同功能的地方，这些功能包括使用存根类，添加一个构造函数参数，添加一个可设置的公共属性，把一个方法改成可以重写的虚拟方法等。
+ 抽取接口使底层实现可替换
    - 使用这种技术需要把和外部依赖打交道的代码分离到一个单独的类中，这样容易识别，以便将来在代码中替换掉对这个类的调用。
    - 抽取出访问文件系统的类进行调用
        ```C#
        public bool IsVaildLogFileName(string fileName)
        {
            // 使用抽取出的类
            FileExtensionManager mgr = new FileExtensionManager();
            return mgr.IsVaild(fileName);
        }
        // 定义抽取出来的文件类
        class FileExtensionManager
        {
            public bool IsVaild(string fileName)
            {
                // 读取文件
            }
        }
        ```
    - 从一个已知的类抽取出一个接口
        ```C#
        // 实现接口
        public class FileExtensionManager : IExtensionManager
        {
            public bool IsVaild(string fileName)
            {
                ...
            }
        }
        // 定义接口
        public interface IExtensionManager
        {
            bool IsVaild(string fileName);
        }
        // 被测试的工作单元
        public bool IsVaildLogFileName(string fileName)
        {
            IExtensionManager mgr = new IExtensionManager();
            return mgr.IsVaild(fileName);
        }
        ```
    - 创建不依赖文件系统的存根
        ```C#
        // 总是返回true的简单存根
        public class AlwaysVaildFakeExtensionManager : IExtensionManager
        {
            public bool IsVaild(string fileName)
            {
                return true;
            }
        }
        ```
+ 依赖注入：在被测试单元中注入一个伪实现
    - 在构造函数层注入一个伪对象（构造函数注入）
    使用这种方法，需要给被测试类添加一个新的构造函数（或给已有的构造函数添加一个新参数），传入抽取出来的接口类型的对象，然后在被测试类中添加一个这个接口类型的局部字段，把传入的对象赋给这个局部字段，供被测试方法或其他方法使用。
    ```C#
        // 产品代码
        public class LogAnalyzer
        {
            private IExtensionManager manager;
            // 定义测试代码可以调用的构造函数
            public LogAnalyzer(IExtensionManager mgr)
            {
                manager = mgr;
            }
            public bool IsValidLogFileName(string fileName)
            {
                return manager.IsValid(fileName);
            }
        }
        // 抽取出来的接口
        public interface IExtensionManager
        {
            bool IsValid(string fileName);
        }
        // 测试代码
        [TestFixture]
        public class LogAnalyzerTests
        {
            [Test]
            public void IsValidFileName_NameSupportedExtension_ReturnsTrue()
            {
                // 准备存根
                FakeExtensionManager fakeManager =new FakeExtensionManager();
                fakeManager.WillBeValid = true;
                // 传入存根
                LogAnalyzer log = new LogAnalyzer(fakeManager);
                bool result = log.IsValidLogFileName("short.exe");
                Assert.True(result);
            }
        }
        // 定义存根
        internal class  FakeExtensionManager : IExtensionManager
        {
            public bool WillBeValid = false;
            public bool IsValid(string fileName)
            {
                return WillBeValid;
            }
        }
    ```
        注意：
        1、如果存在多个依赖，被测试代码需要多个存根才能在没有依赖项的情况下正常工作，加入越来越多的构造函数就变得很困难，甚至还会降低代码的可读性和可维护性。
        2、除非使用类似IoC容器框架来创建对象，使用构造函数参数来初始化对象会使测试代码变得笨拙。
    - 用属性get或set注入伪对象
    使用这种技术，需要为每个要注入的依赖添加一个属性get和set，然后在被测试代码中需要的地方使用这些依赖。
    ```C#
        public class LogAnalyzer
        {
            private IExtensionManager manager;
            public LogAnalyzer()
            {
                manager = new FileExtensionManager();
            }
            // 通过属性设置依赖项
            public IExtensionManager ExtensionManager
            {
                get { return manager; }
                set { manager = value; }
            }
            public bool IsValidLogFileName(string fileName)
            {
                return manager.IsValid(fileName);
            }
        }
        [Test]
        public void IsValidFileName_NameSupportedExtension_ReturnsTrue()
        {
            // 设置要使用的存根，确保其返回true
            ...
            LogAnalyzer log = new LogAnalyzer();
            // 注入存根
            log.ExtensionManager = someFakeManagerCreated;
            // 断言逻辑
            ...
        }
    ```
        注意：
        如果想表明被测试类的某个依赖项是可选的，或者测试可以放心使用默认创建的这个依赖项实例，就可以使用属性注入。
    - 在方法调用前注入伪对象
    1、使用一个工厂类
    一个类在构造函数中初始化管理器，但是它从一个工厂类得到这个管理器的实例。测试中需要配置这个工厂类，让它返回一个存根而不是真实的扩展名管理器实现。
    ```C#
    // 在测试运行时设置工厂类返回一个存根
    public class LogAnalyzer
    {
        private IExtensionManager manager;
        public LogAnalyzer()
        {
            manager = ExtensionManagerFactory.Create();     // 在产品代码中使用工厂类
        }
        public bool IsValidLogFileName(string fileName)
        {
            return manager.IsValid(fileName)
            && Path.GetFileNameWithoutExtension(fileName).Length>5;
        }
    }

    // 定义能使用和返回定制管理器的工厂
    class ExtensionManagerFactory
    {
        private IExtensionManager customManager = null;
        public IExtensionManager Create()
        {
            if(customManager != null)
            {
                return customManager;
            }
            return new FileExtensionManager();
        }
        public void SetManager(IExtensionManager mgr)
        {
            customManager = mgr;
        }
    }

    [Test]
    public void IsValidFileName_SupportedExtension_ReturnsTrue()
    {
        // 设置要使用的存根，使其返回true
        ...
        // 为这个测试设置工厂类中的存根
        ExtensionManagerFactory.SetManager(myFakeManager);
        // 创建Analyzer,注入存根
        LogAnalyzer log = new LogAnalyzer();
        // 断言逻辑
    }
    ```
    2、在发布版本中隐藏接缝
    3、不同的间接层次
    （1）在被测试类中伪造一个成员
    （2）在工厂类中伪造一个成员
    （3）伪造工厂类
    4、仿造方法——使用一个局部的工厂方法（抽取和重写）
    使用被测试类中一个局部的虚方法作为工厂方法，获取扩展名管理器的实例。
    （1）在被测试类中：1.添加一个返回真实实例的虚工厂方法；2.正常在代码中使用工厂方法。
    （2）在测试项目中：1.创建一个新类；2.声明这个新类继承被测试类；3.创建一个要替换的接口类型的公共字段（不需要属性get和set方法）；4.重写虚工厂方法；5.返回公共字段。
    （3）在测试代码中：1.创建一个存根类的实例，此存根类实现了所要求的接口；2.创建新派生类而非被测试类的实例；3.配置这个新实例的公共字段，设置成在测试中创建的存根实例。
    ```C#
    // 伪造一个工厂方法
    public class LogAnalyzerUsingFactoryMethod
    {
        public bool IsValidLogFileName(string fileName)
        {
            return GetManager().IsValid(fileName);      // 使用虚方法
        }
        protected virtual IExtensionManager GetManager()
        {
            return new FileExtensionManager();          // 返回硬编码的值
        }
    }

    class TestableLogAnalyzer : LogAnalyzerUsingFactoryMethod
    {
        public TestableLogAnalyzer(IExtensionManager mgr)
        {
            Manager = mgr;
        }
        public IExtensionManager Manager;
        // 返回指定的值
        protected override IExtensionManager GetManager()
        {
            return Manager;
        }
    }

    internal class FakeExtensionManager : IExtensionManager
    {
        ...
    }

    [TestFixture]
    public class LogAnalyzerTests
    {
        [Test]
        public void overrideTest()
        {
            FakeExtensionManager stub = new FakeExtensionManager();
            stub.WillBeValid = true;
            // 创建被测试类的派生类的实例
            TestableLogAnalyzer logan = new TestableLogAnalyzer(stub);
            bool result = logan.IsValidLogFileName("file.exe");
            Assert.True(result);
        }
    }
    ```
### 3.4 重构技术变种
+ 使用抽取和重写生成假结果
```C#
// 从抽取的方法返回结果而非存根对象
public class LogAnalyzerUsingFactoryMethod
{
    public bool IsValidLogFileName(string fileName)
    {
        return this.IsValid(fileName);
    }
    protected virtual bool IsValid(string fileName)
    {
        FileExtensionManager mgr = new FileExtensionManager();
        return mgr.IsValid(fileName);                   // 从真实依赖返回结果
    }
}

class TestableLogAnalyzer : LogAnalyzerUsingFactoryMethod
{
    public bool IsSupported;
    protected override bool IsValid(string fileName)
    {
        return IsSupported;                         // 返回测试代码设置的假值
    }
}

[Test]
public void overrideTestWithoutStub()
{
    TestableLogAnalyzer logan = new TestableLogAnalyzer();
    logan.IsSupported = true;                           // 设置假结果值
    bool result = logan.IsValidLogFileName("file.exe");
    Assert.True(result,".....");
}
```
### 3.5 克服封装问题
+ 使用internal和[InternalsVisibleTo]
```C#
// 使内部成员对测试程序集可见
public class LogAnlyzer
{
    internal LogAnlyzer(IExtensionManager extentionMgr)
    {
        manager = extentionMgr;
    }
}
using System.Runtime.CompilerService;
[assembly:InternalsVisibleTo("AOUT.CH3.Logan.Tests")]
```
+ 使用[Conditional]属性
+ 使用#if和#endif进行条件编译
---
## 4.使用模拟对象进行交互测试
### 4.1 基于值的测试、基于状态的测试和交互测试
+ 基于值的测试验证一个函数返回的值；基于状态的测试改变被测试系统的状态，然后验证其可见的行为变化；交互测试是对一个对象如何向其他对象发送消息（调用方法）的测试。
### 4.2 模拟对象和存根的区别
+ 模拟对象是系统中的伪对象，它可以验证被测试对象是否按预期的方式调用了这个伪对象，因此导致单元测试通过或是失败。
+ 使用存根时，对被测试类进行断言，存根只是辅助测试运行。
+ 使用模拟对象时，被测试类与模拟对象进行通讯，模拟对象记录所有的通讯，测试使用模拟对象验证测试是否通过。
+ 一个测试有多个存根是完全可行的，但是有多个模拟对象就会产生麻烦，因为多个模拟对象说明你同时测试了多个事情。
### 4.3 手工模拟对象的简单示例
```C#
// 抽取接口
public interface IWebService
{
    void LogError(string message);
}

// 创建模拟对象
public class FakeWebService : IWebService
{
    public string LastError;
    public void LogError(string message)
    {
        LastError = message;
    }
}

// 使用模拟对象测试LogAnalyzer
[Test]
public void Analyze_TooShortFileName_CallsWebService()
{
    FakeWebService mockService = new FakeWebService();
    LogAnalyzer log = new LogAnalyzer(mockService);
    string tooShortFileName = "abc.exe";
    log.Analyze(tooShortFileName);
    StringAssert.Contains("Filename too short:abc.exe",mockService.LastError);              // 对模拟对象进行断言
}

public class LogAnalyzer
{
    private IWebService service;
    public LogAnalyzer(IWebService service)
    {
        this.service = service;
    }
    public void Analyze(string fileName)
    {
        if(fileName.Length<8)
        {
            service.LogError($"Filename too short:{fileName}");
        }
    }
}
```
### 4.4 同时使用模拟对象和存根
```C#
// 使用存根替换Web服务，模拟异常；然后模拟邮件服务，检查调用。测试LogAnalyzer与其他对象的交互
public interface IEmailService
{
    void SendEmail(string to,string subject,string body);
}

public class LogAnalyzer2
{
    public IWebService Service
    {
        get;
        set;
    }
    public IEmailService Email
    {
        get;
        set;
    }
    public LogAnalyzer2(IWebService service,IEmailService email)
    {
        Email = email;
        Service = service;
    }
    public void Analyze(string fileName)
    {
        if(fileName.Length<8)
        {
            try
            {
                Service.LogError($"Filename too short:{fileName}");
            }
            catch(Exception e)
            {
                Email.SendEmail("11@163.com","can't log",e.Message);
            }
        }
    }
}

public class FakeWebService : IWebService
{
    public Exception ToThrow;
    public void LogError(string message)
    {
        if(ToThrow!=null)
        {
            throw ToThrow;
        }
    }
}

/*
public class FakeEmailService : IEmailService
{
    public string To;
    public string Subject;
    public string Body;
    public void SendEmail(string to,string subject,string body)
    {
        To = to;
        Subject = subject;
        Body = body;
    }
}
*/

[TestFixture]
public class LogAnalyzer2Tests
{
    [Test]
    public void Analyze_WebServiceThrow_SendsEmail()
    {
        FakeWebService stubService = new FakeWebService();
        stubService.ToThrow = new Exception("fake exception");
        FakeEmailService mockEmail = new FakeEmailService();

        LogAnalyzer2 log = new LogAnalyzer2(stubService,mockEmail);
        string tooShortFileName = "abc.exe";
        log.Analyze(tooShortFileName);

        // StringAssert.Contains("11@163.com",mockEmail.To);  
        // StringAssert.Contains("fake exception",mockEmail.Body);  
        // StringAssert.Contains("can't log",mockEmail.Subject);  
        // 创建预期对象
        EmailInfo expectedEmail = new EmailInfo{
            Body = "fake exception",
            To = "11@163.com",
            Subject = "can't log";
        }
        Assert.AreEqual(expectedEmail,mockEmail.email);
    }
}

class EmailInfo
{
    public string Body;
    public string To;
    public string Subject;
}

public class FakeEmailService : IEmailService
{
    public EmailInfo email = null;
    public void SendEmail(EmailInfo emailInfo)
    {
        email = emailInfo;
    }
}
```
### 4.5 每个测试一个模拟对象
+ 如果一个测试只测试一件事情，测试中应该最多只有一个模拟对象。
+ 过度指定是过多地指定测试中应该发生的事情的行为，而这些事情实际上对测试无关紧要。
### 4.6 伪对象链：用存根生成模拟对象或其他存根
+ 用一个伪对象（通过方法或属性）返回另一个伪造的组件，生成自己的小存根链，最后生成系统内部深处的一个模拟对象，在测试中收集某些数据。
---
## 5.隔离（模拟）框架
### 5.1 为什么要使用隔离框架
+ 一个隔离框架是一套可编程的API，使用这套API创建伪对象比手工编写容易，而且简洁。
### 5.2 动态生成伪对象
+ 动态伪对象是在运行时创建的任何存根或模拟对象，它的创建不需要手工编写代码（硬编码）。
+ 在测试中使用NSubstitute
    - NSub支持arrange-act-assert模型，这个模型的理念是在测试的==准备==部分创建和配置伪对象，接着对被测试产品==执行==操作，最后在末尾的==断言==部分检验在测试中调用了这个伪对象。
+ 用动态伪对象替换手工伪对象
```C#
// 对手工伪对象断言
[TestFixture]
class LogAnalyzerTests
{
    [Test]
    public void Analyze_TooShortFileName_CallLogger()
    {
        FakeLogger logger = new FakeLogger();       // 创建伪对象

        LogAnalyzer analyzer = new (logger);
        analyzer.MinNameLength = 6;
        analyzer.Analyze("a.txt");

        StringAssert.Contains("too short",logger.LastError);    // 进行断言，把这个伪对象用作模拟对象
    }
}

class FakeLogger : ILogger
{
    public string LastError;
    public void LogError(string message)
    {
        LastError = message;
    }
}

// 使用NSub伪造一个对象
[Test]
public void Analyze_TooShortFileName_CallLogger()
{
    ILogger logger = Substitute.For<ILogger>();                 // 创建模拟对象，用于测试断言

    LogAnalyzer analyzer = new (logger);
    analyzer.MinNameLength = 6;
    analyzer.Analyze("a.txt");

    logger.Received().LogError("Filename too short:a.txt");     // 使用NSub API 设置预期字符串
}
```
### 5.3 模拟值
```C#
// 从伪对象返回一个值
[Test]
public void Returns_ByDefault_WorksForHardCodedArgument()
{
    IFileNameRules fakeRules = Substitute.For<IFileNameRules>();
    fakeRules.IsValidLogFileName("file.name").Returns(true);        //强制方法调用返回假值
    Assert.IsTrue(fakeRules.IsValidLogFileName("file.name"));
}
// 使用参数匹配器（Arg.Any<Type>），忽略具体的参数值
[Test]
public void Returns_ByDefault_WorksForHardCodedArgument()
{
    IFileNameRules fakeRules = Substitute.For<IFileNameRules>();
    fakeRules.IsValidLogFileName(Arg.Any<String>()).Returns(true);        //忽略参数值
    Assert.IsTrue(fakeRules.IsValidLogFileName("anything.txt"));
}
// 模拟异常
[Test]
public void Returns_ArgAny_Throws()
{
    IFileNameRules fakeRules = Substitute.For<IFileNameRules>();
    fakeRules.When(x=>x.IsValidLogFileName(Arg.Any<String>())).Do(
        context=>{throw new Exception("fake exception");}
    );
    Assert.Throws<Exception>(()=>fakeRules.IsValidLogFileName("anything"));     // 用 Assert.Throws验证被测试方法确实抛出了一个异常
}

public interface IFileNameRules
{
    bool IsValidLogFileName(string fileName);
}

```
+ 同时使用模拟对象和存根
### 5.4 测试事件相关的活动
+ 测试事件监听者
+ 测试事件是否触发
### 5.5 现有的.NET隔离框架
### 5.6 隔离框架的优缺点
+ 使用隔离框架时应避开的陷阱
+ 测试代码不可读
+ 验证错误的事情
+ 一个测试多个模拟对象
+ 过度指定测试
---
## 6.深入了解隔离框架
### 6.1 受限框架和不受限框架
+ 受限框架
+ 不受限框架
+ 基于探测器的不受限框架如何工作
### 6.2 优秀隔离框架的价值
### 6.3 支持适应未来和可用性的功能
+ 递归伪对象
+ 默认忽略参数
+ 泛伪造
+ 伪对象的非严格行为
+ 非严格模拟对象
### 6.4 隔离框架设计反模式
+ 概念混淆
+ 录制和重放
+ 粘性行为
+ 复杂语法
---
## 7.测试层次和组织
### 7.1 运行自动化测试的自动化构建
+ 构建脚本结构
+ 触发构建和集成
### 7.2 基于速度和类型布局测试
+ 分离集成测试和单元测试的人为因素
+ 绿色安全区
### 7.3 确保测试是源代码管理的一部分
### 7.4 将测试类映射到被测试代码
+ 将测试映射到项目
+ 将测试映射到类
+ 将测试映射具体的工作单元入口
### 7.5 注入横切关注点
### 7.6 为应用程序构建测试API
+ 使用测试类继承模式
+ 创建测试工具类和方法
+ 把API介绍给开发人员
---
## 8.优秀单元测试的支柱
### 8.1 编写可靠的测试
+ 决定何时删除或修改测试
+ 避免测试中的逻辑
+ 只测试一个关注点
+ 把单元测试和集成测试分开
+ 用代码审查确保代码覆盖率
### 8.2 编写可维护的测试
+ 测试私有或受保护的方法
+ 去除重复代码
+ 以可维护的方式使用setup方法
+ 实施测试隔离
+ 避免对不同关注点多次断言
+ 对象比较
+ 避免过度指定
### 8.3 编写可读的测试
+ 单元测试命名
+ 变量命名
+ 有意义的断言
+ 断言和操作分离
+ setup和teardown
---
## 9.在组织中引入单元测试
### 9.1 逐步成为变革的倡导者
+ 准备好面对质疑
+ 说服组织内成员：支持者和反对者
+ 找到可能的切入点
### 9.2 成功之道
+ 游击式实现（自下向上）
+ 说服高层（自上向下）
+ 引入外援
+ 使进度可见
+ 设定具体目标
+ 应对障碍
### 9.3 失败原因
+ 缺少驱动力
+ 缺少政策支持
+ 不好的实现和第一印象
+ 缺少团队支持
### 9.4 影响因素
### 9.5 质疑和回答
+ 单元测试会给现有流程增加多少时间
+ 单元测试是否会抢QA饭碗
+ 证明单元测试确实有效的方法
+ 单元测试有用的证据
+ QA部门还是能找到缺陷的原因
+ 我们有大量没有测试的代码：应该从哪里开始
+ 我们使用多种编程语言：单元测试是否可行
+ 软硬件结合的开发
+ 确保测试中没有缺陷的方法
+ 代码已经调试通过，还需要测试的原因
+ 驱动开发测试的必要性
---
## 10.遗留代码
### 10.1 从哪里开始增加测试
### 10.2 决定选择策略
+ 先易后难策略的优缺点
+ 先难后易策略的优缺点
### 10.3 在重构前编写集成测试
### 10.4 遗留代码单元测试的重要工具
+ 使用不受限的隔离框架轻松隔离依赖项
+ 使用JMockit测试Java遗留代码
+ 重构Java代码时使用Vise
+ 重构前使用验收测试
---
## 11.设计与可测试性
### 11.1 为什么在设计时要关心可测试性
### 11.2 可测试性的设计目标
+ 默认情况下将方法设置为虚拟方法
+ 使用基于接口的设计
+ 默认情况下将类设置为非密封的
+ 避免在包含逻辑的方法内初始化具体类
+ 避免直接调用静态方法
+ 避免在构造函数和静态构造函数中包含逻辑代码
+ 把单例逻辑和单例持有者分开
### 11.3 可测试性设计的利弊
+ 工作量
+ 复杂度
+ 泄露敏感知识产权
+ 有时无法实现
### 11.4 可测试性设计的替代方法
### 11.5 难以测试的设计示例
 




